name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_version_bump:
        description: 'Skip automatic version bump'
        required: false
        type: boolean
        default: false

# Prevent concurrent deployments - automatically cancel older deployments
concurrency:
  group: production-deployment
  cancel-in-progress: true

permissions:
  contents: write       # For creating tags and releases
  pull-requests: write  # For test workflow PR comments
  issues: write         # For test workflow PR comments

env:
  PRODUCTION_SSH_HOST: jola209.mikrus.xyz
  PRODUCTION_SSH_PORT: 10209
  PRODUCTION_SSH_USER: root
  PRODUCTION_PATH: /root/OnionTravel

jobs:
  tests:
    name: Run Tests
    uses: ./.github/workflows/test.yml
    secrets: inherit

  version-and-release:
    name: Version Bump & Create Release
    runs-on: ubuntu-latest
    needs: [tests]
    if: ${{ !inputs.skip_version_bump }}
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
      old_version: ${{ steps.get_current_version.outputs.version }}
      release_notes: ${{ steps.generate_notes.outputs.notes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.DEPLOY_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: get_current_version
        run: |
          CURRENT_VERSION=$(jq -r '.version' frontend/package.json)
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Get PR labels
        id: pr_labels
        run: |
          # Get PR number from merge commit
          PR_NUMBER=$(gh pr list --state merged --search "${{ github.sha }}" --json number --jq '.[0].number')

          if [ -z "$PR_NUMBER" ]; then
            echo "No PR found for this commit, using default patch bump"
            echo "bump_type=patch" >> $GITHUB_OUTPUT
          else
            # Get PR labels
            LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name')
            echo "PR Labels: $LABELS"

            if echo "$LABELS" | grep -q "version:major"; then
              echo "bump_type=major" >> $GITHUB_OUTPUT
            elif echo "$LABELS" | grep -q "version:minor"; then
              echo "bump_type=minor" >> $GITHUB_OUTPUT
            else
              echo "bump_type=patch" >> $GITHUB_OUTPUT
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Bump version
        id: bump_version
        run: |
          CURRENT_VERSION="${{ steps.get_current_version.outputs.version }}"
          BUMP_TYPE="${{ steps.pr_labels.outputs.bump_type }}"

          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          case $BUMP_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          NEW_VERSION="$major.$minor.$patch"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Bumping version: $CURRENT_VERSION -> $NEW_VERSION ($BUMP_TYPE)"

      - name: Generate release notes
        id: generate_notes
        run: |
          # Get last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            # No previous tags, get all commits
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            # Get commits since last tag
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          # Create release notes
          cat > /tmp/release_notes.md << EOF
          ## Changes since ${LAST_TAG:-initial release}

          $COMMITS

          ---

          **Deployed**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Commit**: ${{ github.sha }}
          **Author**: ${{ github.actor }}
          EOF

          # Save for later use (escape newlines)
          NOTES=$(cat /tmp/release_notes.md)
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Release notes preview:"
          cat /tmp/release_notes.md

      - name: Update version files
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.new_version }}"

          # Update frontend/package.json
          jq ".version = \"$NEW_VERSION\"" frontend/package.json > /tmp/package.json
          mv /tmp/package.json frontend/package.json

          # Update frontend/src/version.ts
          echo "export const APP_VERSION = '$NEW_VERSION';" > frontend/src/version.ts

          echo "Updated version to $NEW_VERSION in:"
          echo "  - frontend/package.json"
          echo "  - frontend/src/version.ts"

      - name: Commit version bump
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.new_version }}"

          git add frontend/package.json frontend/src/version.ts
          git commit -m "Release v$NEW_VERSION [skip ci]

          Updated version to $NEW_VERSION

          ü§ñ Generated with GitHub Actions"

          echo "Created commit for version bump"

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.new_version }}"

          # Create annotated tag with release notes
          git tag -a "v$NEW_VERSION" -F /tmp/release_notes.md

          # Push commit and tag
          git push origin main
          git push origin "v$NEW_VERSION"

          echo "Pushed commit and tag v$NEW_VERSION"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.new_version }}"

          # Create release using gh CLI
          gh release create "v$NEW_VERSION" \
            --title "Release v$NEW_VERSION" \
            --notes-file /tmp/release_notes.md

  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: [tests, version-and-release]
    if: always() && needs.tests.result == 'success' && (needs.version-and-release.result == 'success' || needs.version-and-release.result == 'skipped')

    steps:
      - name: Notify deployment start
        if: ${{ vars.DISCORD_WEBHOOK_URL }}
        env:
          VERSION: ${{ needs.version-and-release.outputs.new_version || 'current' }}
          OLD_VERSION: ${{ needs.version-and-release.outputs.old_version || '' }}
          RELEASE_NOTES: ${{ needs.version-and-release.outputs.release_notes }}
        run: |
          if [ -n "$RELEASE_NOTES" ]; then
            CHANGELOG=$(echo "$RELEASE_NOTES" | grep -E "^[[:space:]]*- " | head -5 || echo "")
            TOTAL_CHANGES=$(echo "$RELEASE_NOTES" | grep -cE "^[[:space:]]*- " || echo "0")
            if [ "$TOTAL_CHANGES" -gt 5 ]; then
              CHANGELOG="${CHANGELOG}"$'\n'"... and $((TOTAL_CHANGES - 5)) more changes"
            fi
          else
            CHANGELOG="No changelog available"
          fi

          CHANGELOG_ESCAPED=$(echo "$CHANGELOG" | \
            sed 's/\\/\\\\/g' | \
            sed 's/"/\\"/g' | \
            sed ':a;N;$!ba;s/\n/\\n/g' | \
            head -c 600)

          if [ -n "$OLD_VERSION" ] && [ "$OLD_VERSION" != "$VERSION" ]; then
            VERSION_DISPLAY="$OLD_VERSION ‚Üí $VERSION"
          else
            VERSION_DISPLAY="$VERSION"
          fi

          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"üöÄ Deployment Started\",
                \"description\": \"Deploying OnionTravel to production\",
                \"color\": 3447003,
                \"fields\": [
                  {\"name\": \"Version\", \"value\": \"$VERSION_DISPLAY\", \"inline\": true},
                  {\"name\": \"Branch\", \"value\": \"main\", \"inline\": true},
                  {\"name\": \"Commit\", \"value\": \"[\`${GITHUB_SHA:0:7}\`]($GITHUB_SERVER_URL/$GITHUB_REPOSITORY/commit/$GITHUB_SHA)\", \"inline\": true},
                  {\"name\": \"Triggered by\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                  {\"name\": \"üìù Changes\", \"value\": \"$CHANGELOG_ESCAPED\", \"inline\": false}
                ],
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" \
            "${{ vars.DISCORD_WEBHOOK_URL }}"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ env.PRODUCTION_SSH_PORT }} ${{ env.PRODUCTION_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Transfer Docker Compose
        run: |
          scp -P ${{ env.PRODUCTION_SSH_PORT }} \
            docker-compose.yml \
            ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }}:${{ env.PRODUCTION_PATH }}/

      - name: Transfer backend files
        run: |
          rsync -avz -e "ssh -p ${{ env.PRODUCTION_SSH_PORT }}" \
            --exclude 'venv' \
            --exclude '__pycache__' \
            --exclude '*.pyc' \
            --exclude '.pytest_cache' \
            --exclude 'htmlcov' \
            --exclude 'data' \
            --exclude 'uploads' \
            ./backend/ \
            ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }}:${{ env.PRODUCTION_PATH }}/backend/

      - name: Transfer frontend files
        run: |
          rsync -avz -e "ssh -p ${{ env.PRODUCTION_SSH_PORT }}" \
            --exclude 'node_modules' \
            --exclude 'dist' \
            --exclude '.vite' \
            ./frontend/ \
            ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }}:${{ env.PRODUCTION_PATH }}/frontend/

      - name: Deploy Docker containers
        run: |
          ssh -p ${{ env.PRODUCTION_SSH_PORT }} \
            ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }} << 'EOF'
            set -e
            cd /root/OnionTravel

            echo "Ensuring Docker network exists..."
            docker network create web 2>/dev/null || true

            echo "Stopping containers..."
            docker compose down

            echo "Building containers..."
            docker compose build

            echo "Starting containers..."
            docker compose up -d

            echo "Docker deployment complete"
          EOF

      - name: Wait for containers to be healthy
        run: |
          ssh -p ${{ env.PRODUCTION_SSH_PORT }} \
            ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }} << 'EOF'
            set -e
            cd /root/OnionTravel

            echo "Waiting for containers to be healthy (max 120 seconds)..."

            TIMEOUT=120
            ELAPSED=0

            while [ $ELAPSED -lt $TIMEOUT ]; do
              BACKEND_HEALTH=$(docker inspect --format='{{.State.Health.Status}}' oniontravel-backend 2>/dev/null || echo "not_found")
              FRONTEND_HEALTH=$(docker inspect --format='{{.State.Health.Status}}' oniontravel-frontend 2>/dev/null || echo "not_found")

              echo "[$ELAPSED s] Backend: $BACKEND_HEALTH | Frontend: $FRONTEND_HEALTH"

              if [ "$BACKEND_HEALTH" = "healthy" ] && [ "$FRONTEND_HEALTH" = "healthy" ]; then
                echo "‚úì All containers are healthy!"
                exit 0
              fi

              if [ "$BACKEND_HEALTH" = "unhealthy" ] || [ "$FRONTEND_HEALTH" = "unhealthy" ]; then
                echo "‚úó Container became unhealthy!"
                docker compose ps
                docker compose logs --tail=50
                exit 1
              fi

              sleep 5
              ELAPSED=$((ELAPSED + 5))
            done

            echo "‚úó Timeout waiting for containers to be healthy"
            docker compose ps
            docker compose logs --tail=50
            exit 1
          EOF

      - name: Test endpoints via Traefik
        run: |
          ssh -p ${{ env.PRODUCTION_SSH_PORT }} \
            ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }} << 'EOF'
            set -e

            echo "Testing endpoints via Traefik..."

            # Test backend health via Traefik
            echo "  - Backend health via Traefik"
            curl -s -f -H "Host: oniontravel.bieda.it" http://localhost/api/v1/health || {
              echo "‚úó Backend health check via Traefik failed"
              # Fallback to direct container test
              echo "  Trying direct container access..."
              docker exec oniontravel-backend curl -s -f http://localhost:7001/health || exit 1
            }
            echo "    ‚úì OK"

            # Test frontend via Traefik
            echo "  - Frontend via Traefik"
            curl -s -f -H "Host: oniontravel.bieda.it" http://localhost/ > /dev/null || {
              echo "‚úó Frontend check via Traefik failed"
              # Fallback to direct container test
              echo "  Trying direct container access..."
              docker exec oniontravel-frontend wget -q -O /dev/null http://localhost/ || exit 1
            }
            echo "    ‚úì OK"

            echo "All endpoint tests passed!"
          EOF

      - name: Get deployment status
        if: always()
        run: |
          ssh -p ${{ env.PRODUCTION_SSH_PORT }} \
            ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }} << 'EOF'
            cd /root/OnionTravel

            echo "=== Docker Container Status ==="
            docker compose ps

            echo ""
            echo "=== Traefik Status ==="
            docker ps | grep traefik || echo "Traefik not running"
          EOF

      - name: Notify deployment success
        if: success() && vars.DISCORD_WEBHOOK_URL
        env:
          VERSION: ${{ needs.version-and-release.outputs.new_version || 'current' }}
          OLD_VERSION: ${{ needs.version-and-release.outputs.old_version || '' }}
          RELEASE_NOTES: ${{ needs.version-and-release.outputs.release_notes }}
        run: |
          if [ -n "$RELEASE_NOTES" ]; then
            CHANGELOG=$(echo "$RELEASE_NOTES" | grep -E "^[[:space:]]*- " | head -15 || echo "")
          else
            CHANGELOG=$(git log --oneline -10 --pretty=format:"- %s" 2>/dev/null || echo "No changelog available")
          fi

          CHANGELOG_ESCAPED=$(echo "$CHANGELOG" | \
            sed 's/\\/\\\\/g' | \
            sed 's/"/\\"/g' | \
            sed ':a;N;$!ba;s/\n/\\n/g' | \
            head -c 900)

          if [ ${#CHANGELOG} -gt 900 ]; then
            CHANGELOG_ESCAPED="${CHANGELOG_ESCAPED}..."
          fi

          if [ -n "$OLD_VERSION" ] && [ "$OLD_VERSION" != "$VERSION" ]; then
            VERSION_DISPLAY="$OLD_VERSION ‚Üí $VERSION"
          else
            VERSION_DISPLAY="$VERSION"
          fi

          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"‚úÖ Deployment Successful\",
                \"description\": \"OnionTravel deployed successfully to production\",
                \"color\": 3066993,
                \"fields\": [
                  {\"name\": \"Version\", \"value\": \"$VERSION_DISPLAY\", \"inline\": true},
                  {\"name\": \"Commit\", \"value\": \"[\`${GITHUB_SHA:0:7}\`]($GITHUB_SERVER_URL/$GITHUB_REPOSITORY/commit/$GITHUB_SHA)\", \"inline\": true},
                  {\"name\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                  {\"name\": \"üìù Changelog\", \"value\": \"$CHANGELOG_ESCAPED\", \"inline\": false},
                  {\"name\": \"Production URL\", \"value\": \"https://oniontravel.bieda.it\", \"inline\": false},
                  {\"name\": \"API Docs\", \"value\": \"https://oniontravel.bieda.it/docs\", \"inline\": false}
                ],
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" \
            "${{ vars.DISCORD_WEBHOOK_URL }}"

      - name: Notify deployment failure
        if: failure() && vars.DISCORD_WEBHOOK_URL
        run: |
          VERSION="${{ needs.version-and-release.outputs.new_version || 'current' }}"

          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"‚ùå Deployment Failed\",
                \"description\": \"OnionTravel deployment to production failed\",
                \"color\": 15158332,
                \"fields\": [
                  {\"name\": \"Version\", \"value\": \"$VERSION\", \"inline\": true},
                  {\"name\": \"Commit\", \"value\": \"[\`${GITHUB_SHA:0:7}\`]($GITHUB_SERVER_URL/$GITHUB_REPOSITORY/commit/$GITHUB_SHA)\", \"inline\": true},
                  {\"name\": \"Triggered by\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                  {\"name\": \"Workflow Run\", \"value\": \"[$GITHUB_RUN_NUMBER]($GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID)\", \"inline\": false}
                ],
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }]
            }" \
            "${{ vars.DISCORD_WEBHOOK_URL }}"

      - name: Deployment summary
        if: success()
        run: |
          VERSION="${{ needs.version-and-release.outputs.new_version || 'current' }}"

          cat << EOF

          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë                  DEPLOYMENT SUCCESSFUL                          ‚ïë
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

          Version:           $VERSION
          Commit:            ${{ github.sha }}
          Deployed by:       ${{ github.actor }}

          Production URLs:
            Frontend:        https://oniontravel.bieda.it
            Backend API:     https://oniontravel.bieda.it/api/v1
            API Docs:        https://oniontravel.bieda.it/docs

          Server Management:
            SSH:             ssh -p ${{ env.PRODUCTION_SSH_PORT }} ${{ env.PRODUCTION_SSH_USER }}@${{ env.PRODUCTION_SSH_HOST }}
            Docker:          cd ${{ env.PRODUCTION_PATH }} && docker compose ps
            Logs:            cd ${{ env.PRODUCTION_PATH }} && docker compose logs -f

          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
          EOF
